import type { CoralRootNode } from '../structures/coral'
import type { ComponentEventDefinition, ComponentEventsDefinition } from '../structures/events'
import type { ComponentPropsDefinition, PropType } from '../structures/props'
import type { ComponentVariants } from '../structures/variants'

/**
 * Generate TypeScript interface for a component's props
 *
 * @param component - Component to generate types for
 * @returns TypeScript interface code
 *
 * @example
 * ```ts
 * const interfaceCode = generatePropsInterface(buttonComponent)
 * // export interface ButtonProps {
 * //   intent?: "primary" | "secondary" | "destructive";
 * //   size?: "sm" | "md" | "lg";
 * //   disabled?: boolean;
 * //   onClick?: (event: React.MouseEvent<HTMLButtonElement>) => void;
 * //   className?: string;
 * //   style?: React.CSSProperties;
 * // }
 * ```
 */
export function generatePropsInterface(component: CoralRootNode): string {
  const name = component.$meta?.name ?? component.componentName ?? component.name
  const lines: string[] = []

  lines.push(`export interface ${name}Props {`)

  // Add variant props
  if (component.componentVariants?.axes) {
    for (const axis of component.componentVariants.axes) {
      const unionType = axis.values.map((v) => `"${v}"`).join(' | ')
      if (axis.description) {
        lines.push(`  /** ${axis.description} */`)
      }
      lines.push(`  ${axis.name}?: ${unionType};`)
    }
  }

  // Add component props
  if (component.props) {
    for (const [propName, def] of Object.entries(component.props)) {
      const tsType = propTypeToTS(def.type)
      const optional = def.required ? '' : '?'

      if (def.description) {
        lines.push(`  /** ${def.description} */`)
      }
      if (def.deprecated) {
        const msg = typeof def.deprecated === 'string' ? def.deprecated : ''
        lines.push(`  /** @deprecated ${msg} */`)
      }

      lines.push(`  ${propName}${optional}: ${tsType};`)
    }
  }

  // Add event handlers
  if (component.events) {
    for (const [eventName, def] of Object.entries(component.events)) {
      const paramsType = eventParamsToTS(def)

      if (def.description) {
        lines.push(`  /** ${def.description} */`)
      }
      if (def.deprecated) {
        const msg = typeof def.deprecated === 'string' ? def.deprecated : ''
        lines.push(`  /** @deprecated ${msg} */`)
      }

      lines.push(`  ${eventName}?: ${paramsType};`)
    }
  }

  // Add className and style for flexibility
  lines.push(`  /** Additional CSS class name */`)
  lines.push(`  className?: string;`)
  lines.push(`  /** Inline styles */`)
  lines.push(`  style?: React.CSSProperties;`)

  lines.push(`}`)

  return lines.join('\n')
}

/**
 * Convert a PropType to a TypeScript type string
 */
export function propTypeToTS(type: PropType): string {
  if (type === 'string') return 'string'
  if (type === 'number') return 'number'
  if (type === 'boolean') return 'boolean'
  if (type === 'ReactNode') return 'React.ReactNode'
  if (type === 'function') return '(...args: unknown[]) => void'
  if (type === 'any') return 'unknown'

  if (typeof type === 'object') {
    if ('enum' in type) {
      return type.enum.map((v) => `"${v}"`).join(' | ')
    }
    if ('array' in type) {
      return `Array<${propTypeToTS(type.array)}>`
    }
    if ('object' in type) {
      const entries = Object.entries(type.object)
        .map(([k, v]) => `${k}: ${propTypeToTS(v)}`)
        .join('; ')
      return `{ ${entries} }`
    }
    if ('union' in type) {
      return type.union.map(propTypeToTS).join(' | ')
    }
  }

  return 'unknown'
}

/**
 * Convert event parameters to TypeScript function type
 */
function eventParamsToTS(event: ComponentEventDefinition): string {
  if (!event.parameters || event.parameters.length === 0) {
    return '() => void'
  }

  const params = event.parameters
    .map((p) => `${p.name}${p.optional ? '?' : ''}: ${p.type}`)
    .join(', ')

  return `(${params}) => void`
}

/**
 * Generate full TypeScript file for a component
 *
 * @param component - Component to generate types for
 * @returns Complete TypeScript declaration file content
 */
export function generateComponentTypes(component: CoralRootNode): string {
  const name = component.$meta?.name ?? component.componentName ?? component.name
  const version = component.$meta?.version ?? '0.0.0'

  const lines: string[] = [
    `// Generated by Coral - Do not edit manually`,
    `// Component: ${name} v${version}`,
    ``,
    `import * as React from "react";`,
    ``,
    generatePropsInterface(component),
    ``,
    `export declare const ${name}: React.FC<${name}Props>;`,
    ``,
  ]

  return lines.join('\n')
}

/**
 * Generate TypeScript types for multiple components
 *
 * @param components - Map of component names to definitions
 * @returns Complete TypeScript declaration file content
 */
export function generatePackageTypes(
  components: Map<string, CoralRootNode>,
): string {
  const lines: string[] = [
    `// Generated by Coral - Do not edit manually`,
    ``,
    `import * as React from "react";`,
    ``,
  ]

  for (const [, component] of components) {
    lines.push(generatePropsInterface(component))
    lines.push('')

    const name = component.$meta?.name ?? component.componentName ?? component.name
    lines.push(`export declare const ${name}: React.FC<${name}Props>;`)
    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Generate JSDoc comment block for a component
 */
export function generateComponentJSDoc(component: CoralRootNode): string {
  const lines: string[] = ['/**']

  if (component.$meta?.description || component.description) {
    lines.push(` * ${component.$meta?.description ?? component.description}`)
    lines.push(` *`)
  }

  // Add variant params
  if (component.componentVariants?.axes) {
    for (const axis of component.componentVariants.axes) {
      const values = axis.values.join(' | ')
      lines.push(` * @param ${axis.name} - ${axis.description ?? `Variant: ${values}`}`)
    }
  }

  // Add prop params
  if (component.props) {
    for (const [propName, def] of Object.entries(component.props)) {
      const desc = def.description ?? `The ${propName} prop`
      const optional = def.required ? '' : '[optional] '
      lines.push(` * @param ${propName} - ${optional}${desc}`)
    }
  }

  // Add event params
  if (component.events) {
    for (const [eventName, def] of Object.entries(component.events)) {
      const desc = def.description ?? `Handler for ${eventName}`
      lines.push(` * @param ${eventName} - ${desc}`)
    }
  }

  if (component.$meta?.version) {
    lines.push(` * @version ${component.$meta.version}`)
  }

  if (component.$meta?.status === 'deprecated') {
    lines.push(` * @deprecated`)
  }

  lines.push(` */`)

  return lines.join('\n')
}

/**
 * Generate variant types as a union
 */
export function generateVariantTypes(variants: ComponentVariants): string {
  const types: string[] = []

  for (const axis of variants.axes) {
    const unionType = axis.values.map((v) => `"${v}"`).join(' | ')
    types.push(`export type ${toPascalCase(axis.name)}Variant = ${unionType};`)
  }

  return types.join('\n')
}

/**
 * Generate constant for variant default values
 */
export function generateVariantDefaults(variants: ComponentVariants): string {
  const defaults: Record<string, string> = {}

  for (const axis of variants.axes) {
    defaults[axis.name] = axis.default
  }

  return `export const variantDefaults = ${JSON.stringify(defaults, null, 2)} as const;`
}

/**
 * Convert a string to PascalCase
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_\s]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join('')
}
